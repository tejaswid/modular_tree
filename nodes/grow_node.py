from bpy.types import Node
from bpy.props import IntProperty, FloatProperty, EnumProperty, BoolProperty, StringProperty
from .base_node import BaseNode
from ..tree import MTree
import random


class MtreeGrow(Node, BaseNode):
    """
    This is the Grow Node in the UI to control how the forks of a split are generated.
    This node should be used with the split node to grow the forks generated by the split node.
    """
    # Label of the node in blender. Use this to access this node in a python script.
    bl_label = "Grow Node"
    # Seed for the random number generation
    seed = IntProperty(default=0, description="Seed for the random number generation")
    # Length of the forks in metres
    length = FloatProperty(min=0, default=7, update=BaseNode.property_changed,
                           description="Length of the roots in metres. min=0, max=inf, default=7")
    # Length of the forks at the base of the tree
    shape_start = FloatProperty(min=0, default=.5, update=BaseNode.property_changed,
                                description="Length of the forks at the base of the tree. min=0, default=0.5")
    # Length of the forks at the end of the tree
    shape_end = FloatProperty(min=0, default=.5, update=BaseNode.property_changed,
                              description="Length of the forks at the top of the tree. min=0, default=0.5")
    # How the length of the forks should change as a function of length of the element on which the fork is growing
    shape_convexity = FloatProperty(default=1, update=BaseNode.property_changed,
                                    description="Tune the length of the forks as a function of the length of the parent"
                                                " on which the fork is growing. default=1")
    # Number of elements (loops or cylinders) the fork has along its axis
    resolution = FloatProperty(min=.002, default=1, update=BaseNode.property_changed,
                               description="Number of elements along the fork's axis. min=0.002, max=inf, default=1")
    # Parameter to tune how irregular the branch looks
    randomness = FloatProperty(default=.1, update=BaseNode.property_changed,
                               description="Tune how irregular the branch looks. default=0.1")
    # How likely it is for a branch to fork
    split_proba = FloatProperty(min=0, max=1, default=.1, update=BaseNode.property_changed,
                                description="Tune how likely it is for a branch to fork. min=0, max=1, default=0.1")
    # Angle with which the fork splits from the main branch in radians todo Why do we have this again? check max
    split_angle = FloatProperty(min=0, max=1, default=.3, update=BaseNode.property_changed,
                                description="Angle with which the fork splits from the main branch."
                                            " min=0, max=1, default=0.3")
    # Radius of the fork at the beginning todo Why do we have this again?
    split_radius = FloatProperty(min=0, max=1, default=.9, update=BaseNode.property_changed,
                                 description="Radius of fork at the base (the split location)."
                                             " min=0, max=1, default=0.9")
    # How constrained on the horizontal axis the forks from the splits are
    split_flatten = FloatProperty(min=0, max=1, default=.5, update=BaseNode.property_changed,
                                  description="How constrained on the horizontal axis the forks are."
                                              " min=0, max=1, default=0.5")
    # Radius of the fork at the end todo Why do we have this again?
    end_radius = FloatProperty(min=0, max=1, default=0, update=BaseNode.property_changed,
                               description="Radius of the fork at the end. min=0, max=1, default=0")
    # Boolean indicating if the fork can spawn leaves
    can_spawn_leafs = BoolProperty(default=True, update=BaseNode.property_changed,
                                   description="Boolean indicating if the fork can spawn leaves")
    # Tune how much the forks go towards the ground/sky
    gravity_strength = FloatProperty(default=.1, update=BaseNode.property_changed,
                                     description="Tune how much the branches go towards the floor or sky. default=0.1")
    # Tune how much the forks avoid the floor
    floor_avoidance = FloatProperty(min=0, default=1, update=BaseNode.property_changed,
                                    description="Tune how much the forks avoid the floor. min=0, default=1")

    properties = ["seed", "length", "shape_start", "shape_end", "shape_convexity", "resolution", "randomness",
                  "split_proba", "split_angle", "split_radius", "split_flatten", "end_radius", "can_spawn_leafs",
                  "gravity_strength", "floor_avoidance"]

    def init(self, context):
        """
        Initialization
        """
        self.outputs.new('TreeSocketType', "0")
        self.inputs.new('TreeSocketType', "Tree")
        self.name = MtreeGrow.bl_label

    def draw_buttons(self, context, layout):
        """
        Draws buttons in the UI
        """
        col = layout.column()
        for i in self.properties:
            col.prop(self, i)
    
    def execute(self, tree, input_node):
        """
        The function that is called when a fork has to be grown from a split.

        This is the function that passes the parameters from the UI to the underlying tree generation functions.
        """
        random.seed(self.seed)
        # get index of node in node tree and use it as tree function identifier
        creator = self.id_data.nodes.find(self.name)
        selection = 0 if input_node == None else input_node.id_data.nodes.find(input_node.name)

        # Grow the forks using th parameters set in the UI
        tree.grow(self.length, self.shape_start, self.shape_end, self.shape_convexity,
                  self.resolution, self.randomness, self.split_proba, self.split_angle,
                  self.split_radius, self.split_flatten, self.end_radius, self.gravity_strength,
                  self.floor_avoidance, self.can_spawn_leafs, creator, selection)

        for output in self.outputs:
            # here the execute function is called recursively on first output of all nodes,
            # the second output of all nodes, etc.
            links = output.links
            if len(links) > 0:
                links[0].to_node.execute(tree, self)
